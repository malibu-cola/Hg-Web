# [ABC343](https://atcoder.jp/contests/abc343)

## A問題(OK)

０以上9以下の$a$と$b$が与えられる。$a + b$に等しくないものを出力。

**解法**：やるだけ。

```rust
// やるだけ
for i in 0..10 {
    if a + b != i {
        println!("{}", i);
        return;
    }
}
```

## B問題(OK)

頂点数$N$のグラフの隣接行列が与えられる。
隣接グラフを各頂点で照準に出力。

**解法**：やるだけ

```rust 
// やるだけ
let mut g = vec![vec![]; n];
for i in 0..n {
    for j in 0..n {
        if a[i][j] == 1 {
            g[i].push(j);
        }
    }
}

for i in 0..n{
    g[i].sort();
    for v in g[i].iter() {
        print!("{} ", v + 1);
    }
    println!();
}
```

## C問題(OK)

整数$N$以下の回文立方数で最大のものを出力。回文立方数とは回文でかつ立方数のもの。

**解法**：やるだけ

```rust
// 立方根を全探索。
    for i in 1.. {
        if i*i*i > n {break;}
        if kaibun(i*i*i) {
            ans = i*i*i;
        }
    }

//回文判定
fn kaibun(x: usize) -> bool {
    let s = x.to_string().chars().collect::<Vec<char>>();
    let mut t = s.clone();
    t.reverse();
    let mut ok = true;
    for i in 0..s.len(){
        ok &= s[i] == t[i];
    }
    return ok;
}
```

## D問題(OK)

$N$人の選手の点数が変動する。
時間$t$において選手$A[t]$の点数が$B[t]$になる。時間$t$ごとに選手の点数の種類を出力。

**解法**：選手iの点数を管理するvecと点数key点の人数を管理するmapを毎秒更新。map.len()を出力。

```rust 

   // 点数key点の人がval人いるmap
    let mut map = HashMap::new();
    // 人iの点数がv[i]点
    let mut v = vec![0; n];

    // 点数0点の人がn人
    map.insert(0, n);
    

    for j in 0..t{
        let (a, b) = p[j];
        // v[a]点の人を一人減らす。
        let x = map.get(&v[a]).unwrap();
        map.insert(v[a], x - 1);
        // もしv[a]点の人が0人だったらmapから消す。
        if map.get(&v[a]) == Some(&0) {
            map.remove(&v[a]);
        }
        // aさんの点数に+b点
        v[a] += b;
        // v[b]点の人を一人増やす。
        *map.entry(v[a]).or_insert(0) += 1;
        println!("{}", map.len());
    }

```

## 問題E

辺の長さが$7$の立方体3つある。ちょうど1, 2, 3個の立方体に含まれる領域の体積が$V_1, V_2, V_3$隣るように配置する。
立方体の体積領域を$(a \le x \le a + 7) \land (b \le x \le b + 7) \land (c \le x \le c + 7)$で定義する時、
$(a1, b1, c1), (a2, b2, c2), (a3, b3, c3)$を求める。

### 考え

- $(a1, b1, c1) = (0, 0, 0)$で固定。
- 対称性より$a2 = b3, c2 = c3$
- $(a2, b2, c2), (a3, b3, c3)$を全探索した場合、各変数が0~7をとるので$8^4 \sim 5000$通り
- 体積の導出がわからなかった。

### サンプル回答

```rust
use itertools::iproduct;

#[fastout]
fn main() {
    input!{
        v1: isize, 
        v2: isize, 
        v3: isize,
    }
    if v1 + 2*v2 + 3*v3 != 1029 {
        println!("No");
        return;
    }

    for (a2, b2, c2) in iproduct!(-1..8, -1..8, -1..8) {
        for (a3, b3, c3) in iproduct!(-1..8, -1..8, -1..8) {
            let v = calc((0, 0, 0), (a2, b2, c2), (a3, b3, c3));
            if v.0 == v1 && v.1 == v2 && v.2 == v3 {
                println!("Yes");
                println!("0 0 0 {} {} {} {} {} {}", a2, b2, c2, a3, b3, c3);
                return;
            }
        }
    }
    println!("No");
}

// 体積を計算する。
fn calc(a: (isize, isize, isize), b: (isize, isize, isize), c: (isize, isize, isize)) -> (isize, isize, isize){
    let ab = c1(a, b);
    let bc = c1(b, c);
    let ca = c1(c, a);
    let v3 = c3(a, b, c);
    let v2 = bc + ca + ab - v3*3;
    let v1 = 1029 - v2*2 - v3*3;
    return (v1, v2, v3);
}

fn c1(a: (isize, isize, isize), b: (isize, isize, isize)) -> isize {
    c2(a.0, b.0) * c2(a.1, b.1) * c2(a.2, b.2)
} 

fn c2(a: isize, b: isize) -> isize {
    0.max(min(a, b) + 7 - max(a, b))
}

fn c3(a: (isize, isize, isize), b: (isize, isize, isize), c: (isize, isize, isize)) -> isize {
    c4(a.0, b.0, c.0) * c4(a.1, b.1, c.1) * c4(a.2, b.2, c.2)
}

fn c4(a: isize, b: isize, c: isize) -> isize{
    0.max(a.min(b).min(c) + 7 - a.max(b).max(c))
}
```

## 問題F

数列$a$とクエリ$q$個が与えられる。

クエリ1
- 形式：$(1, p, x)$
- 内容：$a[p]$に$x$を代入

クエリ2 
- 形式：$(2, l, r)$
- 内容：$(a[l], ..., a[r])$における２番目に大きい値の個数を出力。

### 考え

何も浮かばなかった。
解法見てセグ木を聞いて、あーってなった。

